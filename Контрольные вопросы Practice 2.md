## 1. В чём основные отличия алгоритмов сортировки пузырьком, выбором и вставкой?

Основные отличия этих алгоритмов заключаются в принципе работы и способе перестановки элементов.

* Сортировка пузырьком работает за счёт многократного сравнения соседних элементов. Если элементы стоят не по порядку, они меняются местами. В результате самые большие элементы постепенно «всплывают» в конец массива. Алгоритм простой, но делает много лишних сравнений и обменов.

* Сортировка выбором на каждом шаге ищет минимальный элемент в неотсортированной части массива и ставит его на нужную позицию. В отличие от пузырька, здесь меньше обменов, но количество сравнений всё равно большое.

* Сортировка вставкой формирует отсортированную часть массива постепенно. Каждый новый элемент вставляется в нужное место среди уже отсортированных элементов слева. Этот алгоритм хорошо работает для маленьких или почти отсортированных массивов.

Все три алгоритма имеют сложность O(n²), но ведут себя по-разному на практике.

---

## 2. Почему параллельная реализация сортировки вставкой сложнее для выполнения с использованием OpenMP?

Сортировка вставкой по своей природе последовательная.
Каждый шаг алгоритма зависит от предыдущего шага, потому что:

* элемент на позиции `i` вставляется в уже отсортированную часть массива `[0 … i-1]`;
* пока предыдущие элементы не отсортированы, нельзя корректно обработать следующий элемент.

Из-за этой зависимости шагов нельзя просто распараллелить цикл с помощью `#pragma omp parallel for`, так как это приведёт к ошибкам и неправильному результату.
Поэтому сортировка вставкой плохо подходит для параллельной реализации с OpenMP и почти не даёт прироста производительности.

---

## 3. Какие директивы OpenMP были использованы для параллельной реализации алгоритмов?

В работе использовались следующие директивы OpenMP:

* **`#pragma omp parallel for`**
  Используется для распараллеливания циклов, когда разные итерации цикла могут выполняться независимо друг от друга.

* **`#pragma omp parallel`**
  Создаёт параллельную область, внутри которой работают несколько потоков.

* **`#pragma omp critical`**
  Используется для защиты общего ресурса (например, при поиске глобального минимума в сортировке выбором), чтобы только один поток мог изменять данные в данный момент.

Эти директивы позволяют безопасно распределять работу между потоками на CPU.

---

## 4. Какие преимущества и недостатки параллельной реализации алгоритмов сортировки на CPU?

### Преимущества:

* Возможное ускорение выполнения программы за счёт использования нескольких ядер CPU.
* Более эффективное использование вычислительных ресурсов процессора.
* Полезно для обучения принципам параллельного программирования.

### Недостатки:

* Не все алгоритмы хорошо параллелятся (например, сортировка вставкой).
* Накладные расходы на создание и синхронизацию потоков.
* Для маленьких массивов параллельная версия может работать медленнее, чем последовательная.
* Сложнее реализация и отладка кода.

---

## 5. Как можно измерить производительность программы в C++?

Производительность программы можно измерить с помощью библиотеки **`<chrono>`**.

Обычно делается так:

1. Засекается время до выполнения алгоритма.
2. Выполняется нужный код (например, сортировка).
3. Засекается время после выполнения.
4. Вычисляется разница между двумя моментами времени.

Таким образом можно измерить время работы алгоритма в миллисекундах или микросекундах и сравнить последовательную и параллельную версии.

---

## 6. Как изменяется производительность сортировок при увеличении числа потоков?

При увеличении числа потоков:

* для алгоритмов, которые хорошо параллелятся, время выполнения может уменьшаться;
* ускорение наблюдается до определённого момента, после чего рост числа потоков почти не даёт выигрыша.

Это связано с:

* ограничениями CPU;
* накладными расходами на синхронизацию потоков;
* конфликтами при доступе к общей памяти.

Для алгоритмов с сильными зависимостями между шагами (например, insertion sort) увеличение числа потоков практически не влияет на производительность.

---

## 7. В каких ситуациях параллельная сортировка может быть менее эффективной, чем последовательная?

Параллельная сортировка может быть менее эффективной, если:

* размер массива небольшой;
* алгоритм имеет сильные зависимости между операциями;
* накладные расходы на создание потоков превышают выигрыш от параллелизма;
* используется слишком большое количество потоков для простых операций;
* алгоритм имеет квадратичную сложность O(n²), и параллелизм не компенсирует рост вычислений.
